//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: abc
//   Authors: hx1997
//------------------------------------------------

uint Align( uint value, uint alignment )
{
  return (value + (alignment - 1)) & ~(alignment - 1);
}

void FAlign( uint alignment )
{
  FSeek( Align( FTell(), alignment ) );
}

typedef struct {
    ubyte val <comment="uleb128 element">;
    if(val > 0x7f) {
        ubyte val <comment="uleb128 element">;
        if (val > 0x7f) {
            ubyte val <comment="uleb128 element">;
            if(val > 0x7f) {
                ubyte val <comment="uleb128 element">;
                if(val > 0x7f) {
                    ubyte val <comment="uleb128 element">;
                }
            }
        }
    }
} uleb128 <read=ULeb128Read, comment="Unsigned little-endian base 128 value">;

// get the actual uint value of the uleb128
uint uleb128_value(uleb128 &u) {
    local uint result;
    local ubyte cur;

    result = u.val[0];
    if(result > 0x7f) {
        cur = u.val[1];
        result = (result & 0x7f) | (uint)((cur & 0x7f) << 7);
        if(cur > 0x7f) {
            cur = u.val[2];
            result |= (uint)(cur & 0x7f) << 14;
            if(cur > 0x7f) {
                cur = u.val[3];
                result |= (uint)(cur & 0x7f) << 21;
                if(cur > 0x7f) {
                    cur = u.val[4];
                    result |= (uint)cur << 28;
                }
            }
        }
    }

    return result;
}

typedef struct uleb128 uleb128p1;

int uleb128p1_value(uleb128 &u) {
    return (int)uleb128_value(u) - 1;
}

string ULeb128Read(uleb128 &u) {
    local string s;
    s = SPrintf(s, "0x%X", uleb128_value(u));
    return s;
}

// sleb128
typedef struct {
    ubyte val <comment="sleb128 element">;
    if(val > 0x7f) {
        ubyte val <comment="sleb128 element">;
        if (val > 0x7f) {
            ubyte val <comment="sleb128 element">;
            if(val > 0x7f) {
                ubyte val <comment="sleb128 element">;
                if(val > 0x7f) {
                    ubyte val <comment="sleb128 element">; 
                }
            }
        }
    }
} sleb128 <read=SLeb128Read, comment="Signed little-endian base 128 value">;

// get the actual uint value of the uleb128
int sleb128_value(sleb128 &u) {
    local int result;
    local ubyte cur;

    result = u.val[0];
    if(result <= 0x7f) {
        result = (result << 25) >> 25;
    } else {
        cur = u.val[1];
        result = (result & 0x7f) | ((uint)(cur & 0x7f) << 7);
        if(cur <= 0x7f) {
            result = (result << 18) >> 18;
        } else {
            cur = u.val[2];
            result |= (uint)(cur & 0x7f) << 14;
            if(cur <= 0x7f) {
                result = (result << 11) >> 11;
            } else {
                cur = u.val[3];
                result |= (uint)(cur & 0x7f) << 21;
                if(cur <= 0x7f) {
                    result = (result << 4) >> 4;
                } else {
                    cur = u.val[4];
                    result |= (uint)cur << 28;
                }
            }
        }
    }

    return result;
}

string SLeb128Read(sleb128 &u) {
    local string s;
    s = SPrintf(s, "%i", sleb128_value(u));
    return s;
}

typedef struct {
    uleb128 utf16_length <comment="len << 1 | is_ascii where len is the length of the string in UTF-16 code units.">;
    string data <comment="0-terminated character sequence in MUTF-8 encoding.">;
} String <read=data>;

typedef struct {
    char panda[5];
    char padding[3];

    if(Strcmp(panda, "PANDA") || padding[0] != 0 || padding[1] != 0 || padding[2] != 0) {
        PrintWarning("Invalid ABC file");
        return -1;
    }
} abc_magic <read=AbcMagicRead, size=8>;

string AbcMagicRead(abc_magic &m) {
    string s;
    SPrintf(s, "%s\\0\\0\\0", m.panda);
    return s;
}

typedef struct {
    abc_magic magic <comment="Magic string. Must be 'P' 'A' 'N' 'D' 'A' '\\0' '\\0' '\\0'">; 
    uint checksum <comment="adler32 checksum of the file except magic and checksum fields.">;
    uchar version[4] <comment="Version of the format.">;
    uint filesize <comment="Size of the file in bytes.">;
    uint foreign_off <comment="Offset to the foreign region. The region must contain elements only of types ForeignField, ForeignMethod, or ForeignClass. It is not necessary foreign_off points to the first entity. Runtime should use foreign_off and foreign_size to determine type of an offset.">;
    uint foreign_size <comment="Size of the foreign region in bytes.">;
    uint num_classes <comment="Number of classes defined in the file. Also this is the number of elements in the ClassIndex structure.">;
    uint class_idx_off <comment="Offset to the class index structure. The offset must point to a structure in ClassIndex format.">;
    uint num_lnps <comment="Number of line number programs in the file. Also this is the number of elements in the LineNumberProgramIndex structure.">;
    uint lnp_idx_off <comment="Offset to the line number program index structure. The offset must point to a structure in LineNumberProgramIndex format.">;
    uint num_literalarrays <comment="Number of literalArrays defined in the file. Also this is the number of elements in the LiteralArrayIndex structure.">;
    uint literalarray_idx_off <comment="Offset to the literalarray index structure. The offset must point to a structure in LiteralArrayIndex format.">;
    uint num_index_regions <comment="Number of the index regions in the file. Also this is the number of elements in the RegionIndex structure.">;
    uint index_section_off <comment="Offset to the index section. The offset must point to a structure in RegionIndex format.">;
    FAlign(4);
} Header <size=readHeaderItemSize>;

int readHeaderItemSize(Header &item) {
    return 56;
}

typedef struct {
    uleb128 type_idx <comment="Index + 1 of the exception's type the block handles in a ClassRegionIndex structure or 0 in case of catch all block. Corresponding index entry must be an offset to a ForeignClass or to Class. The case when the index is 0 means it is a catch all block which catches all exceptions.">;
    uleb128 handler_pc <comment="pc of the first instruction of the exception handler.">;
    uleb128 code_size <comment="Handler's code size in bytes">;
} CatchBlock;

typedef struct {
    uleb128 start_pc <comment="Start pc of the try block. This pc points to the first instruction covered by this try block.">;
    uleb128 length <comment="Number of instructions covered by the try block.">;
    uleb128 num_catches <comment="Number of catch blocks associated with the try block.">;
    CatchBlock catch_blocks[uleb128_value(num_catches)] <optimize=false, comment="Array of catch blocks associated with the try block. The array has num_catches elements in CatchBlock format. Catch blocks follows in the order runtime must check the exception's type. The catch all block, if present, must be the last.">;
} TryBlock;

typedef struct {
    uleb128 num_vregs <comment="Number of registers (without argument registers).">;
    uleb128 num_args <comment="Number of arguments.">;
    uleb128 code_size <comment="Size of instructions in bytes.">;
    uleb128 tries_size <comment="Number of try blocks.">;
    uchar instructions[uleb128_value(code_size)] <comment="Instructions.">;
    TryBlock try_blocks[uleb128_value(tries_size)] <optimize=false, comment="Array of try blocks. The array has tries_size elements in TryBlock format.">;
} Code;

typedef struct {
    uint name_off <comment="Offset to the element's name. The offset must point to a String.">;
    readStringAt(name_off);
    uint value <comment="Value of the element. If the annotation element has type boolean, byte, short, char, int or float the field value contains the value itself in the corresponding Value format. Else the field contains offset to a Value. Format of the value could be determined based on element's type.">;
} AnnotationElement;

typedef struct {
    ushort class_idx <comment="Index of the declaring class in a ClassRegionIndex structure. Corresponding index entry must be an offset to a Class or a ForeignClass.">;
    ushort count <comment="Number of name-value pairs in the annotation (number of elements in elements array).">;
    AnnotationElement elements[count] <comment="Array of annotation elements. Each element is in AnnotationElement format. Order of elements must be the same as they follow in the annotation class.">;
    uchar element_types[count] <comment="Array of annotation element's types. Each element in the array describes the type of AnnotationElement. The order of elements in the array matches the order of elements field.">;
} Annotation;

void readCodeAt(uint offset) {
    local int64 pos;
    local int color;
    if (offset != 0) {
        color = GetBackColor();
        pos = FTell();
        FSeek(offset);
        SetBackColor(cLtYellow);
        Code code_data <comment="Code data.">;
        FSeek(pos);
        SetBackColor(color);
    }
}

typedef struct {
    uchar tag_value <comment="The first 8 bits contain tag which determines the meaning of the data. Depending on the tag there may be optional data. Runtime must be able to determine size of the data.">;
    switch (tag_value) {
    case 0:  // NOTHING
        break;
    case 1:  // INTERFACES
        uleb128 num_interfaces <comment="Number of interfaces.">;
        ushort interfaces_idx[uleb128_value(num_interfaces)] <comment="Indexes of the interfaces in a ClassRegionIndex structure. Each index is 2 bytes long and must be resolved to offset point to a ForeignClass or to a Class.">;
        break;
    case 2:  // SOURCE_LANG
        uchar source_lang <comment="Data represents the source language.">;
        break;
    case 3:  // RUNTIME_ANNOTATION
        uint runtime_annotation <comment="Offset to runtime visible annotation of the class. The tag may be repeated in case the class has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 4:  // ANNOTATION
        uint annotation <comment="Offset to runtime invisible annotation of the class. The tag may be repeated in case the class has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 5:  // RUNTIME_TYPE_ANNOTATION
        uchar runtime_type_annotation <comment="Offset to runtime visible type annotation of the class. The tag may be repeated in case the class has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 6:  // TYPE_ANNOTATION
        uchar type_annotation <comment="Offset to runtime invisible type annotation of the class. The tag may be repeated in case the class has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 7:  // SOURCE_FILE
        uchar source_file <comment="Offset to a file name string containing source code of this class.">;
        break;
    }
} ClassTag;

uint getFieldTypeByIdx(ushort type_idx) {
    local int i;
    local uint64 pos = FTell();
    for (i = 0; i < abc_header.num_index_regions; i++) {
        if (pos < abc_region_idxs.region_headers[i].start_off || pos > abc_region_idxs.region_headers[i].end_off)
            continue;
        return abc_region_idxs.region_headers[i].class_idx.types[type_idx].field_type;
    }
}

void readFieldValue(uint field_type) {
    if (field_type < 16) {
        switch (field_type) {
            case 0x0:  // u1
            case 0x2:  // u8
                uchar value <comment="Contains value in the Value format.">;
                break;
            case 0x1:  // i8
                char value <comment="Contains value in the Value format.">;
                break;
            case 0x3:  // i16
                short value <comment="Contains value in the Value format.">;
                break;
            case 0x4:  // u16
                ushort value <comment="Contains value in the Value format.">;
                break;
            case 0x5:  // i32
                int value <comment="Contains value in the Value format.">;
                break;
            case 0x6:  // u32
                uint value <comment="Contains value in the Value format.">;
                break;
            case 0x7:  // f32
                float value <comment="Contains value in the Value format.">;
                break;
            case 0x8:  // f64
                double value <comment="Contains value in the Value format.">;
                break;
            case 0x9:  // i64
                int64 value <comment="Contains value in the Value format.">;
                break;
            case 0xa:  // u64
                uint64 value <comment="Contains value in the Value format.">;
                break;
            case 0xb:  // any
                // TODO
                break;
        }
    } else {
        uint value <comment="Contains value in the Value format.">;
    }
}

typedef struct (ushort type_idx) {
    uchar tag_value <comment="The first 8 bits contain tag which determines the meaning of the data. Depending on the tag there may be optional data. Runtime must be able to determine size of the data.">;
    switch (tag_value) {
    case 0:  // NOTHING
        break;
    case 1:  // INT_VALUE
        sleb128 int_value <comment="Integral value of the field. This tag is used when the field has type boolean, byte, char, short or int.">;
        break;
    case 2:  // VALUE
        local uint field_type = getFieldTypeByIdx(type_idx);
        readFieldValue(field_type);
        break;
    case 3:  // RUNTIME_ANNOTATIONS
        uint runtime_annotations <comment="Offset to runtime visible annotation of the field. The tag may be repeated in case the field has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 4:  // ANNOTATIONS
        uint annotations <comment="Offset to runtime invisible annotation of the field. The tag may be repeated in case the field has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 5:  // RUNTIME_TYPE_ANNOTATION
        uint runtime_type_annotation <comment="Offset to runtime visible type annotation of the field. The tag may be repeated in case the class has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 6:  // TYPE_ANNOTATION
        uint type_annotation <comment="Offset to runtime invisible type annotation of the field. The tag may be repeated in case the class has several annotations. The offset must point to the value in Annotation format.">;
        break;
    }
} FieldTag;

typedef struct {
    uchar tag_value <comment="The first 8 bits contain tag which determines the meaning of the data. Depending on the tag there may be optional data. Runtime must be able to determine size of the data.">;
    switch (tag_value) {
    case 0:  // NOTHING
        break;
    case 1:  // CODE
        uint code <comment="Data represents the offset to method's code. The offset must point to Code.">;
        readCodeAt(code);
        break;
    case 2:  // SOURCE_LANG
        uchar source_lang <comment="Data represents the source language.">;
        break;
    case 3:  // RUNTIME_ANNOTATION
        uint runtime_annotation <comment="Data represents the offset to runtime visible annotation of the method. The tag may be repeated in case the method has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 4:  // RUNTIME_PARAM_ANNOTATION
        uint runtime_param_annotation <comment="Data represents the offset to the runtime visible annotations of the method's parameters. The offset must point to the value in ParamAnnotations format.">;
        break;
    case 5:  // DEBUG_INFO
        uint debug_info <comment="Data represents the offset to debug information related to the method. The offset must point to DebugInfo.">;
        break;
    case 6:  // ANNOTATIONS
        uint annotations <comment="Data represents the offset to runtime invisible annotation of the method. The tag may be repeated in case the method has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 7:  // PARAM_ANNOTATION
        uint param_annotation <comment="Data represents the offset to the runtime invisible annotations of the method's parameters. The offset must point to the value in ParamAnnotations format.">;
        break;
    case 8:  // TYPE_ANNOTATION
        uint type_annotation <comment="Data represents the offset to runtime invisible type annotation of the method. The tag may be repeated in case the method has several annotations. The offset must point to the value in Annotation format.">;
        break;
    case 9:  // RUNTIME_TYPE_ANNOTATION
        uint runtime_type_annotation <comment="Data represents the offset to runtime visible type annotation of the method. The tag may be repeated in case the method has several annotations. The offset must point to the value in Annotation format.">;
        break;
    }
} MethodTag;

void readStringAt(uint offset) {
    local int64 pos;
    if (offset != 0) {
        pos = FTell();
        FSeek(offset);
        String str <comment="String">;
        FSeek(pos);
    }
}

typedef struct {
    ushort class_idx <comment="Index of the declaring class in a ClassRegionIndex structure. Corresponding index entry must be an offset to a Class.">;
    ushort type_idx <comment="Index of the field's type in a ClassRegionIndex structure. Corresponding index entry must be in FieldType format.">;
    uint name_off <comment="Offset to the name of the field. The offset must point to a String">;
    readStringAt(name_off);
    uleb128 access_flags <comment="Access flags of the field. The value must be a combination of the Field access flags.">;
    FieldTag field_data(type_idx);
    while (field_data.tag_value != 0) {
        FieldTag field_data(type_idx);
    }
} Field;

typedef struct {
    ushort class_idx <comment="Index of the declaring class in a ClassRegionIndex structure. Corresponding index entry must be an offset to a Class.">;
    ushort proto_idx <comment="Index of the method's prototype in a ProtoRegionIndex structure. Corresponding index entry must be an offset to a Proto.">;
    uint name_off <comment="Offset to the name of the method. The offset must point to a String.">;
    readStringAt(name_off);
    uleb128 access_flags <comment="Access flags of the method. The value must be a combination of Method access flags.">;
    MethodTag method_data;
    while (method_data.tag_value != 0) {
        MethodTag method_data;
    }
} Method;

typedef struct {
    String name <comment="Name of the class. The name must conform to TypeDescriptor syntax.">;
    uint super_class_off <comment="Offset to the name of the super class or 0 for root object class (panda.Object in Panda Assembly, plugin-specific in plugins). Non-zero offset must point to a ForeignClass or to a Class.">;
    uleb128 access_flags <comment="Access flags of the class. The value must be a combination of Class access flags.">;
    uleb128 num_fields <comment="Number of fields the class has.">;
    uleb128 num_methods <comment="Number of methods the class has.">;
    ClassTag class_data;
    while (class_data.tag_value != 0) {
        ClassTag class_data;
    }
    Field fields[uleb128_value(num_fields)] <optimize=false, comment="Class fields. Number of elements is num_fields. Each element must have Field format.">;
    Method methods[uleb128_value(num_methods)] <optimize=false, comment="Class methods. Number of elements is num_methods. Each element must have Method format.">;
} class_item;

typedef struct {
    uchar insns;
    while (insns != 0) {  // END_SEQUENCE opcode
        uchar insns;
    }
} LineNumberProgram;

typedef struct {
    uchar tag;
    switch (tag) {
        case 0x0:   // shouldn't be here according to source code but... seems to work?
            uchar value;
            break;
        case 0x2:   // LiteralTag::INTEGER
        case 0x17:  // LiteralTag::LITERALBUFFERINDEX
            uint value;
            break;
        case 0x4:   // LiteralTag::DOUBLE
            double value;
            break;
        case 0x1:   // LiteralTag::BOOL
            uchar value;
            break;
        case 0x3:   // LiteralTag::FLOAT
            float value;
            break;
        case 0x5:   // LiteralTag::STRING
        case 0x6:   // LiteralTag::METHOD
        case 0x7:   // LiteralTag::GENERATORMETHOD
        case 0x18:  // LiteralTag::LITERALARRAY
        case 0x16:  // LiteralTag::ASYNCGENERATORMETHOD
            uint value;
            break;
        case 0x9:   // LiteralTag::METHODAFFILIATE
            ushort value;
            break;
        case 0x19:  // LiteralTag::BUILTINTYPEINDEX
        case 0x8:   // LiteralTag::ACCESSOR
        case 0xff:  // LiteralTag::NULLVALUE
            uchar value;
            break;
        case 0xa:   // LiteralTag::ARRAY_U1
        case 0xb:   // LiteralTag::ARRAY_U8
            uchar value;
            break;
        case 0xc:   // LiteralTag::ARRAY_I8
            char value;
            break;
        case 0xd:   // LiteralTag::ARRAY_U16
            ushort value;
            break;
        case 0xe:   // LiteralTag::ARRAY_I16
            short value;
            break;
        case 0xf:   // LiteralTag::ARRAY_U32
            uint value;
            break;
        case 0x10:  // LiteralTag::ARRAY_I32
            int value;
            break;
        case 0x11:  // LiteralTag::ARRAY_U64
            uint64 value;
            break;
        case 0x12:  // LiteralTag::ARRAY_I64
            int64 value;
            break;
        case 0x13:  // LiteralTag::ARRAY_F32
            float value;
            break;
        case 0x14:  // LiteralTag::ARRAY_F64
            double value;
            break;
        case 0x15:  // LiteralTag::ARRAY_STRING
            uint value;
            break;
    }
} Literal;

uint GetActualNumLiterals(uint num_literals) {
    local uint64 pos = FTell();

    local int i;
    local uint actual_num_literals = 0;
    local uchar tag;
    for (i = 0; i < num_literals / 2; i++) {
        tag = ReadUByte(pos);
        pos++;
        switch (tag) {
            case 0x0:   // shouldn't be here according to source code but... seems to work?
                pos += 1;
                actual_num_literals++;
                break;
            case 0x2:   // LiteralTag::INTEGER
            case 0x17:  // LiteralTag::LITERALBUFFERINDEX
                pos += 4;
                actual_num_literals++;
                break;
            case 0x4:   // LiteralTag::DOUBLE
                pos += 8;
                actual_num_literals++;
                break;
            case 0x1:   // LiteralTag::BOOL
                pos += 1;
                actual_num_literals++;
                break;
            case 0x3:   // LiteralTag::FLOAT
                pos += 4;
                actual_num_literals++;
                break;
            case 0x5:   // LiteralTag::STRING
            case 0x6:   // LiteralTag::METHOD
            case 0x7:   // LiteralTag::GENERATORMETHOD
            case 0x18:  // LiteralTag::LITERALARRAY
            case 0x16:  // LiteralTag::ASYNCGENERATORMETHOD
                pos += 4;
                actual_num_literals++;
                break;
            case 0x9:   // LiteralTag::METHODAFFILIATE
                pos += 2;
                actual_num_literals++;
                break;
            case 0x19:  // LiteralTag::BUILTINTYPEINDEX
            case 0x8:   // LiteralTag::ACCESSOR
            case 0xff:  // LiteralTag::NULLVALUE
                pos += 1;
                actual_num_literals++;
                break;
            case 0xa:   // LiteralTag::ARRAY_U1
            case 0xb:   // LiteralTag::ARRAY_U8
            case 0xc:   // LiteralTag::ARRAY_I8
                pos += 1;
                actual_num_literals++;
                i = num_literals / 2;
                break;
            case 0xd:   // LiteralTag::ARRAY_U16
            case 0xe:   // LiteralTag::ARRAY_I16
                pos += 2;
                actual_num_literals++;
                i = num_literals / 2;
                break;
            case 0xf:   // LiteralTag::ARRAY_U32
            case 0x10:  // LiteralTag::ARRAY_I32
                pos += 4;
                actual_num_literals++;
                i = num_literals / 2;
                break;
            case 0x11:  // LiteralTag::ARRAY_U64
            case 0x12:  // LiteralTag::ARRAY_I64
                pos += 8;
                actual_num_literals++;
                i = num_literals / 2;
                break;
            case 0x13:  // LiteralTag::ARRAY_F32
                pos += 4;
                actual_num_literals++;
                i = num_literals / 2;
                break;
            case 0x14:  // LiteralTag::ARRAY_F64
                pos += 8;
                actual_num_literals++;
                i = num_literals / 2;
                break;
            case 0x15:  // LiteralTag::ARRAY_STRING
                actual_num_literals++;
                i = num_literals / 2;
                break;
            default:    // invalid tag
                i = num_literals / 2;
                break;
        }
    }
    return actual_num_literals;
}

typedef struct {
    uint num_literals <comment="num of literals that a literalarray has.">;
    // Actual number of literals is `num_literals / 2` if no `LiteralTag::ARRAY_*` types are present.
    // If any of these types is present, the actual number stops at the first occurrence (i.e., no more literals once a `LiteralTag::ARRAY_*` type is encountered), no matter what `num_literals / 2` is.
    // I don't know why this is so designed, see source code at `arkcompiler\runtime_core\libpandafile\literal_data_accessor-inl.h`
    local uint actual_num_literals = GetActualNumLiterals(num_literals);
    Literal literals[actual_num_literals] <optimize=false, comment="Array of literal in one LiteralArray. The array has num_literals elements in Literal format.">;
} LiteralArray;

typedef struct {
    uint field_type <comment="Since the first bytes of the file contain the header and size of the header > 16 bytes, any offset in the range [0; sizeof(Header)) is invalid. FieldType encoding uses this fact to encode primitive types of the field in the low 4 bits. For non-primitive type the value is an offset to Class or to ForeignClass. In both cases FieldType is uint32_t.">;
} FieldType;

typedef struct {
    String name;
} ForeignClass;

typedef struct {
    ushort class_idx <comment="Index of the declaring class in a ClassRegionIndex structure. Corresponding index entry must be an offset to a Class or a ForeignClass.">;
    ushort type_idx <comment="Index of the field's type in a ClassRegionIndex structure. Corresponding index entry must be in FieldType format.">;
    uint name_off <comment="Offset to the name of the field. The offset must point to a String">;
    readStringAt(name_off);
} ForeignField;

typedef struct {
    ushort class_idx <comment="Index of the declaring class in a ClassRegionIndex structure. Corresponding index entry must be an offset to a Class or a ForeignClass.">;
    ushort proto_idx <comment="Index of the method's prototype in a ProtoRegionIndex structure. Corresponding index entry must be an offset to a Proto.">;
    uint name_off <comment="Offset to the name of the field. The offset must point to a String">;
    readStringAt(name_off);
    uleb128 access_flags <comment="Access flags of the method. The value must be a combination of Method access flags. For foreign methods, only ACC_STATIC flag is used, other flags should be ignored.">;
} ForeignMethod;

typedef struct (uint offset, int size) {
    local uint64 pos = FTell();
    FSeek(offset);
    SetBackColor(0xd060d0);
    FieldType types[size] <optimize=false, comment="Array of FieldType structures.">;
    FAlign(4);
    FSeek(pos);
} ClassRegionIndex;

typedef struct (uint offset, int size) {
    local uint64 pos = FTell();
    FSeek(offset);
    SetBackColor(0xd060d0);
    uint offsets[size] <optimize=false, comment="Array of offsets to Method or ForeignMethod structures.">;
    FAlign(4);

    //local int i;
    //local uint foreign_start = abc_header.foreign_off;
    //local uint foreign_end = foreign_start + abc_header.foreign_size - 1;
    //local uint method_addr;
    //for (i = 0; i < size; i++) {
    //    method_addr = offsets[i];
    //    FSeek(method_addr);
    //    if (foreign_start <= method_addr && method_addr <= foreign_end)
    //        ForeignMethod abc_method_items <optimize=false>;
    //    else
    //        Method abc_method_items <optimize=false>;
    //}
    
    FSeek(pos);
} MethodRegionIndex;

typedef struct (uint offset, int size) {
    local uint64 pos = FTell();
    FSeek(offset);
    SetBackColor(0xd060d0);
    uint offsets[size] <optimize=false, comment="Array of offsets to Field or ForeignField structures.">;
    FAlign(4);

    local int i;
    local uint foreign_start = abc_header.foreign_off;
    local uint foreign_end = foreign_start + abc_header.foreign_size - 1;
    local uint field_addr;
    for (i = 0; i < size; i++) {
        field_addr = offsets[i];
        FSeek(field_addr);
        if (foreign_start <= field_addr && field_addr <= foreign_end)
            ForeignField abc_field_items <optimize=false>;
        else
            Field abc_field_items <optimize=false>;
    }

    FSeek(pos);
} FieldRegionIndex;

typedef struct (uint offset, int size) {
    local uint64 pos = FTell();
    FSeek(offset);
    SetBackColor(0xd060d0);
    uint offsets[size] <optimize=false, comment="Array of offsets to Proto structures.">;
    FAlign(4);
    FSeek(pos);
} ProtoRegionIndex;

typedef struct {
    uint start_off <comment="Start offset of the region.">;
    uint end_off <comment="End offset of the region.">;
    uint class_idx_size <comment="Number of elements in the ClassRegionIndex structure. Max value is 65536.">;
    uint class_idx_off <comment="Offset to the class index structure. The offset must point to a structure in ClassRegionIndex format.">;
    ClassRegionIndex class_idx(class_idx_off, class_idx_size) <comment="The structure is organized as an array of FieldType. Number of elements in the index is class_idx_size from RegionHeader.">;
    uint method_idx_size <comment="Number of elements in the MethodRegionIndex structure. Max value is 65536.">;
    uint method_idx_off <comment="Offset to the method index structure. The offset must point to a structure in MethodRegionIndex format.">;
    MethodRegionIndex method_idx(method_idx_off, method_idx_size) <comment="The structure is organized as an array of offsets from the beginning og the file to the Method or the ForeignMethod structure. Number of elements in the index is method_idx_size from RegionHeader.">;
    uint field_idx_size <comment="Number of elements in the FieldRegionIndex structure. Max value is 65536.">;
    uint field_idx_off <comment="Offset to the field index structure. The offset must point to a structure in FieldRegionIndex format.">;
    FieldRegionIndex field_idx(field_idx_off, field_idx_size) <comment="The structure is organized as an array of offsets from the beginning og the file to the Field or the ForeignField structure. Number of elements in the index is field_idx_size from RegionHeader.">;
    uint proto_idx_size <comment="Number of elements in the ProtoRegionIndex structure. Max value is 65536.">;
    uint proto_idx_off <comment="Offset to the proto index structure. The offset must point to a structure in ProtoRegionIndex format.">;
    ProtoRegionIndex proto_idx(proto_idx_off, proto_idx_size) <comment="The structure is organized as an array of offsets from the beginning og the file to the Proto structure. Number of elements in the index is proto_idx_size from RegionHeader.">;
    FAlign(4);
} RegionHeader;

typedef struct (int size) {
    uint class_def[size] <comment="Class structure offset", optimize=false>;
    FAlign(4);
    local uint64 pos = FTell();
    
    SetBackColor(cLtBlue);
    local int i;
    local uint foreign_start = abc_header.foreign_off;
    local uint foreign_end = foreign_start + abc_header.foreign_size - 1;
    local uint class_addr;
    for (i = 0; i < size; i++) {
        class_addr = class_def[i];
        FSeek(class_addr);
        if (foreign_start <= class_addr && class_addr <= foreign_end)
            ForeignClass abc_class_items <optimize=false>;
        else
            class_item abc_class_items <optimize=false>;
    }
    FSeek(pos);
} ClassIndex;

typedef struct (int size) {
    uint offsets[size] <comment="Array of offsets to Line Number Program structures.", optimize=false>;
    FAlign(4);
    local uint64 pos = FTell();
    
    SetBackColor(cLtRed);
    local uint i;
    local uint lnp_addr;
    for (i = 0; i < size; i++) {
        lnp_addr = offsets[i];
        FSeek(lnp_addr);
        LineNumberProgram abc_line_num_programs <optimize=false, comment="A line number program consists of instructions. Each instruction has one byte opcode and optional arguments. Depending on opcode argument's value may be encoded into the instruction or the instruction requires reading the value from constant pool.">;
    }
    FSeek(pos);
} LineNumberProgramIndex;

typedef struct (int size) {
    uint offsets[size] <comment="Sorted array of offsets to LiteralArray structures.">;
    FAlign(4);
    local uint64 pos = FTell();

    SetBackColor(cLtAqua);
    local uint i;
    local uint literalarray_addr;
    for (i = 0; i < size; i++) {
        literalarray_addr = offsets[i];
        FSeek(literalarray_addr);
        LiteralArray abc_literalarrays <optimize=false>;
    }
    FSeek(pos);
} LiteralArrayIndex;

typedef struct (int size) {
    SetBackColor(0xa030a0);
    RegionHeader region_headers[size] <optimize=false, comment="To address file structures using 16-bit indexes file is split into regions. Each region has class, method, field and proto indexes and described by RegionHeader structure.">;
    FAlign(4);
} RegionIndex;

SetBackColor(cLtGreen);
Header abc_header <comment="ABC file header">;

FSeek(abc_header.index_section_off);
SetBackColor(0xa030a0);
RegionIndex abc_region_idxs(abc_header.num_index_regions) <comment="RegionIndex structure is aimed to allow runtime to find index structure that covers specified offset in the file. It is organized as an array of RegionHeader structures. All regions are sorted by the start offset of the region. Number of elements in the index is num_index_regions from Header.">;

FSeek(abc_header.class_idx_off);
SetBackColor(cDkBlue);
ClassIndex abc_class_idxs(abc_header.num_classes) <comment="The structure is organized as an array of offsets from the beginning of the file to the Class or ForeignClass structures. All the offsets are sorted by corresponding class names. Number of elements in the index is num_classes from Header.">;

FSeek(abc_header.lnp_idx_off);
SetBackColor(cDkRed);
LineNumberProgramIndex abc_line_num_program_idxs(abc_header.num_lnps) <comment="The structure is organized as an array of offsets from the beginning of the file to the Line Number Program structures. Number of elements in the index is num_lnps from Header.">;

FSeek(abc_header.literalarray_idx_off);
SetBackColor(cDkAqua);
LiteralArrayIndex abc_literalarray_idxs(abc_header.num_literalarrays) <comment="The structure is organized as an array of offsets from the beginning of the file to the LiteralArray structures. Number of elements in the index is num_literalarrays from Header.">;
